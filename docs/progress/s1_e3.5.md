# Sprint 1 - Étape 3.5 (S1E3.5)

## Objectif

Livrer la version **v0.1.1**. Cette étape ajoute l'infrastructure Docker nécessaire pour le développement et le déploiement du projet DM.

## Détails des modifications

### `Dockerfile`

**Image de base et dépendances**

- Python 3.11-slim
- Installation du client PostgreSQL
- Configuration du répertoire de travail `/app`
- Installation des dépendances Python depuis `requirements.txt`

### `docker-compose.yml`

**Services configurés**

- **db** : PostgreSQL 16-alpine
  - Volume persistant `postgres_data`
  - Healthcheck avec `pg_isready`
  - Port 5432 exposé
- **web** : Django 5.2.6
  - Build depuis le Dockerfile local
  - Hot-reload activé (volume monté)
  - Port 8000 exposé
  - Dépend du service `db` (healthcheck)

### `.env.docker.example`

**Variables d'environnement**

- Configuration PostgreSQL (DB_NAME, DB_USER, DB_PASSWORD, DB_HOST, DB_PORT)
- Template pour faciliter le setup local

### `.dockerignore`

**Exclusions du build Docker**

- `.venv/`, `__pycache__/`, fichiers temporaires
- Optimisation de la taille de l'image

### `scripts/docker-inits.sh`

**Script d'initialisation**

- Automatisation des migrations et du superuser (pour Linux/Nexus)

### `.gitignore`

**Ajouts**

- `.env.docker` (secrets)
- `postgres_data/` (données locales)
- `.claude/` (config IDE)

---

## Livraison v0.1.1

- **Docker Compose** : projet tourne avec `docker-compose up`
- **PostgreSQL** : base de données persistante et isolée
- **Hot-reload** : modifications de code reflétées instantanément
- **Healthcheck** : Django attend que PostgreSQL soit prêt

### Résultat attendu

- Lancement du projet en une commande : `docker-compose up`
- Infrastructure identique en dev (local/Nexus) et prod (VPS)
- Base pour le déploiement futur

➡️ Version taguée **v0.1.1**.
