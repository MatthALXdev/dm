# Sprint 1 - Étape 3.6 (S1E3.6)

## Objectif

Livrer la version **v0.1.2**. Cette étape corrige la configuration Docker et ajoute les données de test initiales pour le projet DM.

## Détails des modifications

### `docker-compose.yml`

**Migration des variables d'environnement**

- **Passage de `env_file` à interpolation** : Les variables du service `db` utilisent désormais `${VARIABLE}` au lieu de valeurs hard-codées
- **Convention Docker Compose** : Utilisation du fichier `.env` à la racine (chargé automatiquement)
- **Service db** :
  - `POSTGRES_DB: ${DB_NAME}`
  - `POSTGRES_USER: ${DB_USER}`
  - `POSTGRES_PASSWORD: ${DB_PASSWORD}`
- **Service web** :
  - `env_file` pointe désormais vers `.env` au lieu de `.env.docker`
  - Variables d'environnement interpolées depuis `.env`

**Correction du healthcheck PostgreSQL**

- Ancien : `pg_isready -U dm_user` (générait un warning dans les logs)
- Nouveau : `pg_isready -U dm_user -d dm_db` (test explicite de la base `dm_db`)
- **Impact** : Élimine le message `FATAL: database "dm_user" does not exist` des logs
- **Note** : Le healthcheck fonctionnait déjà (exit code 0), cette correction améliore uniquement la clarté des logs

### `core/fixtures/initial_data.json`

**Données de test**

- Création de 3 produits de démonstration :
  1. **Pack Nature** (9.99€) - 10 fonds d'écran nature HD
  2. **Pack Abstract** (14.99€) - 15 fonds d'écran abstraits
  3. **Pack Minimal** (19.99€) - 20 fonds d'écran minimalistes
- Structure complète : `model`, `pk`, `fields` (name, slug, description, price, created_at)
- Chargement : `docker compose exec web python manage.py loaddata initial_data`

### `.env` (nouveau fichier)

**Variables d'environnement centralisées**

- Remplacement de `.env.docker` par convention Docker Compose standard
- Contient toutes les variables pour PostgreSQL et Django
- **Non versionné** (protégé par `.gitignore`)
- Template fourni dans `.env.example`

### `docs/versions/s1_versions.md`

**Ajout de v0.1.2**

- Documentation des corrections et améliorations
- Temps réel estimé : 1h

---

## Problèmes résolus

### 1. Chargement des variables d'environnement

**Problème initial** :
- `env_file: .env.docker` ne chargeait pas correctement les variables pour le service `db`
- Erreur PostgreSQL : `POSTGRES_PASSWORD not set`
- Solution temporaire : valeurs hard-codées (non sécurisé pour versionning)

**Solution appliquée** :
- Migration vers interpolation `${VARIABLE}` dans `docker-compose.yml`
- Docker Compose charge automatiquement `.env` à la racine
- Les variables sont **interpolées avant** la création des conteneurs
- Code sans secrets → push GitHub sécurisé

**Explication technique** :
- `env_file` injecte des variables **brutes** dans le conteneur (nom exact requis)
- `${VARIABLE}` fait une **substitution** avant la création du conteneur (Docker lit `.env`)
- Source : [Docker Compose Environment Variables](https://docs.docker.com/compose/environment-variables/)

### 2. Warning healthcheck PostgreSQL

**Symptôme** :
```
FATAL: database "dm_user" does not exist
```

**Cause** :
- `pg_isready -U dm_user` cherche une base nommée `dm_user` par défaut
- La base réelle s'appelle `dm_db`

**Comportement observé** :
- Le healthcheck **réussissait quand même** (exit code 0)
- `pg_isready` teste seulement la **disponibilité du serveur PostgreSQL**, pas l'existence d'une base spécifique
- Le warning provenait de tentatives de connexion réelles, pas du healthcheck

**Correction** :
- Ajout de `-d dm_db` pour tester explicitement la bonne base
- Impact : Logs plus propres, pas d'amélioration fonctionnelle

### 3. Base de données vide sur Nexus

**Contexte** :
- Après clone du projet sur Nexus, la base PostgreSQL était vide (nouvelle instance)
- Les produits créés en local (PC) n'ont pas été transférés

**Solution** :
- Création de fixtures Django standardisées
- Fichier JSON versionné avec les données de test
- Chargement reproductible : `python manage.py loaddata initial_data`

---

## Livraison v0.1.2

### Fonctionnalités

- ✅ **Configuration Docker sécurisée** : Variables interpolées depuis `.env`, plus de secrets hard-codés
- ✅ **Fixtures Django** : 3 produits de test chargés via `loaddata`
- ✅ **Healthcheck amélioré** : Logs PostgreSQL propres
- ✅ **README mis à jour** : Documentation des deux environnements (local + Nexus)

### Résultat attendu

- `docker-compose.yml` peut être versionné sans exposer de secrets
- Base de données peuplée automatiquement avec données de test
- Setup reproductible sur n'importe quel environnement
- Documentation claire pour développeurs externes

### Accès application

**Local** :
- Application : http://localhost:8000
- Admin Django : http://localhost:8000/admin

**Nexus (serveur)** :
- Application : http://192.168.1.22:8000 ou http://nexus:8000
- Admin Django : http://192.168.1.22:8000/admin
- **Note** : Le hostname `nexus` peut forcer HTTPS selon la config HSTS du navigateur. Utiliser l'IP en cas de problème.

---

## Apprentissages techniques

### Docker Compose et variables d'environnement

**`env_file` vs `${INTERPOLATION}`** :

| Méthode | Comportement | Use case |
|---------|--------------|----------|
| `env_file: .env` | Injecte variables brutes dans conteneur | Variables internes à l'app |
| `${VAR}` | Substitution avant build | Config Docker Compose |

**Convention Docker Compose** :
- Fichier `.env` à la racine chargé **automatiquement**
- Pas besoin de spécifier `--env-file .env`
- Alternative : `docker compose --env-file .env.custom`

### PostgreSQL `pg_isready`

**Ce que fait `pg_isready`** :
- Test de **disponibilité réseau** du serveur PostgreSQL
- Ne se connecte **pas** réellement à une base de données
- Retourne exit code 0 si le serveur accepte des connexions

**Pourquoi `-d database` est optionnel** :
- `pg_isready` ne vérifie **pas** l'existence de la base spécifiée
- Le paramètre `-d` améliore uniquement la clarté des logs

Source : [PostgreSQL pg_isready Documentation](https://www.postgresql.org/docs/current/app-pg-isready.html)

### Django Fixtures

**Avantages** :
- Données de test versionnées avec le code
- Setup reproductible sur tous les environnements
- Idéal pour démos, tests, CI/CD

**Alternatives** :
- Django Admin : création manuelle (non reproductible)
- Scripts Python : plus flexible mais plus complexe
- Seeds (à la Rails) : nécessite package tiers

---

## Temps réel

- **Estimation** : 1h
- **Réel** : ~2h30
  - Debug variables d'environnement : 1h30
  - Fixtures + healthcheck : 30 min
  - Documentation : 30 min

---

## Prochaines étapes

### Immédiat (avant push)
- [ ] Vérifier que `.env` est bien dans `.gitignore`
- [ ] Tester `docker compose up -d` sur une machine tierce (validation reproductibilité)
- [ ] Commit + tag v0.1.2

### Sprint 1 - Suite
- [ ] Tests unitaires Django (pytest)
- [ ] CI/CD GitHub Actions
- [ ] Déploiement VPS avec Nginx + HTTPS

➡️ Version taguée **v0.1.2**.